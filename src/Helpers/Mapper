<?php
require_once __DIR__ . "/../autoload.php";

use YandexDirectSDK\Common\ConsoleLauncher;
use YandexDirectSDK\Common\Arr;
use YandexDirectSDK\Common\Str;
use YandexDirectSDK\Common\Dir;
use YandexDirectSDK\Common\File;
use YandexDirectSDK\Common\FileInfo;
use YandexDirectSDK\Interfaces\ModelCommon as ModelCommonInterface;
use YandexDirectSDK\Interfaces\Model as ModelInterface;
use YandexDirectSDK\Interfaces\ModelCollection as ModelCollectionInterface;
use YandexDirectSDK\Components\Service;
use YandexDirectSDK\Components\Result;
use YandexDirectSDK\Components\QueryBuilder;

class Mapper extends ConsoleLauncher{

    /**
     * @var Dir
     */
    protected $rootDir;

    /**
     * @var Dir
     */
    protected $modelDir;

    /**
     * @var Dir
     */
    protected $collectionDir;

    /**
     * @var Dir
     */
    protected $serviceDir;

    /**
     * @var string
     */
    protected $objectClass;

    /**
     * @var ReflectionClass
     */
    protected $objectReflection;

    /**
     * Mapper constructor.
     * @throws Exception
     */
    public function __construct()
    {
        $this->rootDir = Dir::bind(__DIR__.'/../');
        $this->modelDir =  Dir::bind($this->rootDir->realPath)->change('Models');
        $this->collectionDir =  Dir::bind($this->rootDir->realPath)->change('Collections');
        $this->serviceDir =  Dir::bind($this->rootDir->realPath)->change('Services');
    }

    public function execute()
    {
        $settings = [];

        $this->bind('model', function($options) use (&$settings){
            $settings[] = [
                'namespace' => 'YandexDirectSDK\\'.$this->modelDir->name,
                'methods' => ['model'],
                'files' => $this->getFiles($this->modelDir->realPath, $options['model'].'.php')
            ];
        });

        $this->bind('model all', function() use (&$settings){
            $settings[] = [
                'namespace' => 'YandexDirectSDK\\'.$this->modelDir->name,
                'methods' => ['model'],
                'files' => $this->getFiles($this->modelDir->realPath)
            ];
        });

        $this->bind('collection', function($options) use (&$settings){
            $settings[] = [
                'namespace' => 'YandexDirectSDK\\'.$this->collectionDir->name,
                'methods' => ['collection'],
                'files' => $this->getFiles($this->collectionDir->realPath, $options['collection'].'.php')
            ];
        });

        $this->bind('collection all', function() use (&$settings){
            $settings[] = [
                'namespace' => 'YandexDirectSDK\\'.$this->collectionDir->name,
                'methods' => ['collection'],
                'files' => $this->getFiles($this->collectionDir->realPath)
            ];
        });

        $this->bind('service', function($options) use (&$settings){
            $settings[] = [
                'namespace' => 'YandexDirectSDK\\'.$this->serviceDir->name,
                'methods' => ['service'],
                'files' => $this->getFiles($this->serviceDir->realPath, $options['service'].'.php')
            ];
        });

        $this->bind('service all', function() use (&$settings){
            $settings[] = [
                'namespace' => 'YandexDirectSDK\\'.$this->serviceDir->name,
                'methods' => ['service'],
                'files' => $this->getFiles($this->serviceDir->realPath)
            ];
        });

        $this->bind('all', function() use (&$settings) {
            $settings[] = [
                'namespace' => 'YandexDirectSDK\\'.$this->modelDir->name,
                'methods' => ['model'],
                'files' => $this->getFiles($this->modelDir->realPath)
            ];

            $settings[] = [
                'namespace' => 'YandexDirectSDK\\'.$this->collectionDir->name,
                'methods' => ['collection'],
                'files' => $this->getFiles($this->collectionDir->realPath)
            ];

            $settings[] = [
                'namespace' => 'YandexDirectSDK\\'.$this->serviceDir->name,
                'methods' => ['service'],
                'files' => $this->getFiles($this->serviceDir->realPath)
            ];
        });

        $this->start();

        Arr::each($settings, function($setting){
            Arr::each($setting['files'], function (File $modelFile) use ($setting){

                $this->objectClass = $setting['namespace'].'\\'.Str::replaceLast('.php', '', $modelFile->name);
                $this->objectReflection = new ReflectionClass($this->objectClass);

                foreach ($setting['methods'] as $method){
                    $lexemes = $this->{'get' . ucfirst($method) . 'Lexemes'}();
                    $this->createDoc($modelFile, $lexemes);
                }

            });
        });
    }

    /**
     * @param $class
     * @return array
     * @throws ReflectionException
     */
    protected function getClassLexemes($class){
        $methods = (new ReflectionClass($class))->getMethods();

        $lexemes = [];

        foreach ($methods as $method){
            $methodName = $method->getName();

            $methodNative = $method->getDeclaringClass()->getName() === (is_object($class) ? get_class($class) : $class);

            $methodReturnType = (function() use ($method){
                if (is_null($type = $method->getReturnType())){
                    return Result::class;
                }

                if (class_exists($type = $type->getName())){
                    return $type;
                } else {
                    return $type;
                }
            })();

            $methodParameters = (function() use ($method){
                if (is_null($parameters = $method->getParameters())){
                    return '';
                }

                $lexemes = [];

                foreach ($parameters as $index => $parameter){
                    if ($parameter->isVariadic()){
                        $parameterName = '...$' . $parameter->getName();
                    } else {
                        $parameterName = '$'.$parameter->getName();
                    }

                    if (is_null($parameterType = $parameter->getType())){
                        $parameterType = '';
                    } else {
                        $parameterType = $parameterType . ' ';
                    }

                    if ($parameter->isDefaultValueAvailable()){
                        if ($parameter->isDefaultValueConstant()){
                            $parameterDefaultValue = $parameter->getDefaultValueConstantName();
                        } else {
                            $parameterDefaultValue = $parameter->getDefaultValue();
                            $parameterDefaultValue = json_encode($parameterDefaultValue);
                            $parameterDefaultValue = str_replace(['{','}','"'], ['[',']','\''], $parameterDefaultValue);
                        }
                    } else {
                        $parameterDefaultValue = '';
                    }

                    $lexemes[] = [
                        'type' => $parameterType,
                        'var' => $parameterName,
                        'default' => $parameterDefaultValue
                    ];
                }

                return $lexemes;
            })();

            $lexemes[$methodName] = [
                'native' => $methodNative,
                'name' => $methodName,
                'params' => $methodParameters,
                'return' => $methodReturnType
            ];
        }

        return $lexemes;
    }

    /**
     * Creates a map of dynamic properties and methods for a model.
     *
     * @return array
     * @throws ReflectionException
     * @throws Exception
     */
    protected function getModelLexemes(): array
    {
        $modelLexemes = [
            'property' => [],
            'property-write' => [],
            'property-read' => [],
            'method' => [],
            'method-write' => [],
            'method-read' => []
        ];

        /**
         * @var ModelInterface $modelClass
         */

        $modelClass = $this->objectClass;
        $modelMethodsMeta = $modelClass::getServiceMethods();
        $modelPropertiesMeta = $modelClass::getProperties();

        $providers = [];

        foreach ($modelMethodsMeta as $alias => $provider){

            /**
             * @var Service $service
             * @var string $provider
             */

            if (!class_exists($provider)){
                $this->warning("Model [{$this->objectReflection->name}]. Service provider [{$provider}] for the method [{$alias}] does not exist.");
                continue;
            }

            $service = $provider;

            if (array_key_exists($provider, $providers)){
                $methods = $providers[$provider]['methods'];
            } else {
                $methods = $providers[$provider]['methods'] = $this->getClassLexemes($provider);
            }

            if (array_key_exists($alias, $service::getMethods())){
                $method = $service::getMethods()[$alias]['type'];
            } else {
                $method = $alias;
            }

            if (array_key_exists($method, $methods)){

                if ($methods[$method]['native']){
                    $methods[$method]['params'] = array_slice($methods[$method]['params'], 1);
                } else {
                    $methods[$method]['params'] = [];
                }

                $methods[$method]['name'] = $alias;

                $modelLexemes['method'][] = $methods[$method];

            } else {

                $this->warning("Service provider [{$provider}] does not implement method [{$alias}], which is declared in model [{$this->objectReflection->name}].");
                continue;

            }
        }

        foreach ($modelPropertiesMeta as $property){

            $resultType = '';

            switch ($property['type']){
                case 'numeric': $resultType = 'integer'; break;
                case 'enum': $resultType = 'string'; break;
                case 'set': $resultType = 'string[]'; break;
                case 'array':
                    if (!empty($property['meta']) and is_array($property['meta'])){
                        $resultType = implode('[]|',$property['meta']).'[]';
                    } else {
                        $resultType = 'array';
                    }
                    break;

                case 'object':
                    $resultType = is_null($property['meta']) ? 'object' : $property['meta'];
                    break;

                case 'custom':
                    if (!empty($property['meta']) and is_array($property['meta'])){
                        $resultType = implode('|',$property['meta']);
                    }
                    break;

                default: $resultType = $property['type'];
            }

            $toCreate = [];

            if ($property['writable'] === true and $property['readable'] === true) {
                $toCreate = ['property', 'method-read', 'method-write'];
            } elseif ($property['writable'] === true) {
                $toCreate = ['property-write', 'method-write'];
            } elseif ($property['readable'] === true) {
                $toCreate = ['property-read', 'method-read'];
            }

            foreach ($toCreate as $createItemType){
                switch ($createItemType){
                    case 'property':
                    case 'property-write':
                    case 'property-read':

                        $modelLexemes[$createItemType][] = [
                            'type' => $resultType,
                            'var' => '$'.$property['name'],
                            'default' => ''
                        ];
                        break;

                    case 'method-write':

                        $modelLexemes[$createItemType][] = [
                            'native' => false,
                            'name' => 'set'.ucfirst($property['name']),
                            'params' => [
                                [
                                    'type' => $resultType,
                                    'var' => '$'.$property['name'],
                                    'default' => ''
                                ]
                            ],
                            'return' => '$this'
                        ];
                        break;

                    case 'method-read':

                        $modelLexemes[$createItemType][] = [
                            'native' => false,
                            'name' => 'get'.ucfirst($property['name']),
                            'params' => [],
                            'return' => $resultType
                        ];
                        break;
                }
            }
        }

        return $modelLexemes;
    }

    /**
     * Creates a map of dynamic properties and methods for a collection.
     *
     * @return array
     * @throws ReflectionException
     * @throws Exception
     */
    protected function getCollectionLexemes()
    {
        $collectionLexemes = [
            'property' => [],
            'property-write' => [],
            'property-read' => [],
            'method' => [],
            'method-write' => [],
            'method-read' => []
        ];

        /**
         * @var ModelCollectionInterface $collectionClass
         */

        $collectionClass = $this->objectClass;
        $collectionCompatibleModel = $collectionClass::getCompatibleModel();
        $collectionMethodsMeta = $collectionClass::getServiceMethods();

        if (is_null($collectionCompatibleModel)){
            $this->warning("Collection [{$this->objectReflection->name}]. Compatible model not defined.");
            return $collectionLexemes;
        }

        $providers = [];

        foreach ($collectionMethodsMeta as $alias => $provider){

            /**
             * @var Service $service
             * @var string $provider
             */

            if (!class_exists($provider)){
                $this->warning("Collection [{$this->objectReflection->name}]. Service provider [{$provider}] for the method [{$alias}] does not exist.");
                continue;
            }

            $service = $provider;

            if (array_key_exists($provider, $providers)){
                $methods = $providers[$provider]['methods'];
            } else {
                $methods = $providers[$provider]['methods'] = $this->getClassLexemes($provider);
            }

            if (array_key_exists($alias, $service::getMethods())){
                $method = $service::getMethods()[$alias]['type'];
            } else {
                $method = $alias;
            }

            if (array_key_exists($method, $methods)){

                if ($methods[$method]['native']){
                    $methods[$method]['params'] = array_slice($methods[$method]['params'], 1);
                } else {
                    $methods[$method]['params'] = [];
                }

                $methods[$method]['name'] = $alias;

                $collectionLexemes['method'][] = $methods[$method];

            } else {

                $this->warning("Service provider [{$provider}] does not implement method [{$alias}], which is declared in collection [{$this->objectReflection->name}].");
                continue;

            }
        }

        return $collectionLexemes;
    }

    /**
     * Creates a map of dynamic properties and methods for a service.
     *
     * @return array
     * @throws ReflectionException
     * @throws Exception
     */
    protected function getServiceLexemes()
    {
        $serviceLexemes = [
            'property' => [],
            'property-write' => [],
            'property-read' => [],
            'method' => [],
            'method-write' => [],
            'method-read' => []
        ];

        /** @var Service $serviceClass */
        /** @var string $serviceModelClass */
        /** @var string $serviceModelCollectionClass */

        $serviceClass = $this->objectClass;
        $serviceName = $serviceClass::getName();
        $serviceModelClass = $serviceClass::getModelClass();
        $serviceModelCollectionClass = $serviceClass::getModelCollectionClass();
        $serviceMethodsMeta = $serviceClass::getMethods();

        if (is_null($serviceName)){
            $this->warning("Service provider [{$this->objectReflection->name}]. Service name is missing.");
            return $serviceLexemes;
        }

        if (empty($serviceMethodsMeta)){
            $this->warning("Service provider [{$this->objectReflection->name}]. Service methods is missing.");
            return $serviceLexemes;
        }

        if (is_null($serviceModelClass) or is_null($serviceModelCollectionClass)){
            $this->warning("Service provider [{$this->objectReflection->name}]. Dependent model or collection of models is not declared.");
            return $serviceLexemes;
        }

        if (!class_exists($serviceModelClass)){
            $this->warning("Service provider [{$this->objectReflection->name}]. The dependent model [{$serviceModelClass}] is not exist.");
            return $serviceLexemes;
        }

        if (!class_exists($serviceModelCollectionClass)){
            $this->warning("Service provider [{$this->objectReflection->name}]. The dependent model collection [{$serviceModelCollectionClass}] is not exist.");
            return $serviceLexemes;
        }

        foreach ($serviceMethodsMeta as $alias => $method){

            $return = null;
            $params = null;

            switch ($method['type']){
                case 'addCollection':
                case 'updateCollection':
                    $return = Result::class;
                    $params = [
                        [
                            'type' => $serviceModelClass.'|'.$serviceModelCollectionClass.'|'.ModelCommonInterface::class,
                            'var' => '$'.lcfirst((new ReflectionClass($serviceModelCollectionClass))->getShortName()),
                            'default' => ''
                        ]
                    ];
                    break;

                case 'addModel':
                case 'updateModel':
                    $return = Result::class;
                    $params = [
                        [
                            'type' => $serviceModelClass.'|'.ModelInterface::class,
                            'var' => '$'.lcfirst((new ReflectionClass($serviceModelClass))->getShortName()),
                            'default' => ''
                        ]
                    ];
                    break;

                case 'actionByIds':
                    $return = Result::class;
                    $params = [
                        [
                            'type' => 'integer|integer[]|'.$serviceModelClass.'|'.$serviceModelCollectionClass.'|'.ModelCommonInterface::class,
                            'var' => '$'.lcfirst((new ReflectionClass($serviceModelCollectionClass))->getShortName()),
                            'default' => ''
                        ]
                    ];
                    break;

                case 'selectionElements':
                    $return = QueryBuilder::class;
                    $params = [];
                    break;

                case 'selectionByIds':
                    $return = $serviceModelClass.'|'.$serviceModelCollectionClass.'|null';
                    $params = [
                        [
                            'type' => 'integer|integer[]|'.$serviceModelClass.'|'.$serviceModelCollectionClass.'|'.ModelCommonInterface::class,
                            'var' => '$ids',
                            'default' => ''
                        ],
                        [
                            'type' => 'string[]',
                            'var' => '$fields',
                            'default' => ''
                        ]
                    ];
                    break;

                default:
                    $this->warning("Service provider [{$this->objectReflection->name}] declares an unknown type of method [{$method['type']}].");
                    continue;
            }

            $serviceLexemes['method'][] = [
                'native' => false,
                'name' => $alias,
                'params' => $params,
                'return' => $return
            ];
        }

        return $serviceLexemes;
    }

    /**
     * Generates class documentation.
     *
     * @param File $sourceCodeFile
     * @param $lexemes
     * @throws Exception
     */
    protected function createDoc(File $sourceCodeFile, $lexemes): void
    {
        $doc = '';
        $sourceCodeContent = $sourceCodeFile->content();

        $maxLenTag = 0;
        $maxLenType = 0;

        foreach ($lexemes as $lexemeType => $lexemeGroup){

            if (empty($lexemeGroup)){
                continue;
            }

            if (strpos($lexemeType, 'method')){
                $maxLenTag = max($maxLenTag, 7);
            } else {
                $maxLenTag = max($maxLenTag, strlen($lexemeType)+1);
            }

            foreach ($lexemeGroup as $lexemeIndex => $lexeme){
                if (isset($lexeme['return'])){
                    $lexeme['return'] = empty($lexeme['return']) ? '' : $this->classNameNormalization($lexeme['return'], $sourceCodeContent);
                    $lexemes[$lexemeType][$lexemeIndex]['return'] = $lexeme['return'];
                    $maxLenType = max($maxLenType, strlen($lexeme['return']));
                }

                if (isset($lexeme['type'])){
                    $lexeme['type'] = empty($lexeme['type']) ? '' : $this->classNameNormalization($lexeme['type'], $sourceCodeContent);
                    $lexemes[$lexemeType][$lexemeIndex]['type'] = $lexeme['type'];
                    $maxLenType = max($maxLenType, strlen($lexeme['type']));
                }
            }
        }

        $doc .= "/** \n";
        $doc .= " * Class ".$this->objectReflection->getShortName()." \n";
        $doc .= " * \n";

        foreach ($lexemes as $lexemeType => $lexemeGroup){
            if (empty($lexemeGroup)){
                continue;
            }

            if (in_array($lexemeType, ['property','property-write','property-read'])){
                foreach ($lexemeGroup as $item){
                    $tag = str_pad('@'.$lexemeType, $maxLenTag, ' ');
                    $type = str_pad($item['type'], $maxLenType, ' ');
                    $doc .= " * {$tag}   {$type}   {$item['var']}\n";
                }
                $doc .= " * \n";
            }

            if (in_array($lexemeType, ['method','method-write','method-read'])){
                foreach ($lexemeGroup as $item){
                    $tag = str_pad('@method', $maxLenTag, ' ');
                    $result = str_pad($item['return'], $maxLenType, ' ');
                    $params = '';
                    foreach ($item['params'] as $param){
                        $params .= empty($param['type']) ? '' : $this->classNameNormalization($param['type'], $sourceCodeContent) . ' ';
                        $params .= $param['var'];
                        $params .= empty($param['default']) ? '' : ' = ' . $param['default'];
                        $params .= ', ';
                    }
                    $params = substr($params,0,-2);
                    $doc .= " * {$tag}   {$result}   {$item['name']}({$params})\n";
                }
                $doc .= " * \n";
            }
        }

        $doc .= " * @package {$this->objectReflection->getNamespaceName()} \n";
        $doc .= " */";

        $this->applyDoc($sourceCodeFile, $doc);
    }

    /**
     * Sets documentation into class source code.
     *
     * @param File $sourceCodeFile
     * @param string $doc
     * @throws Exception
     */
    protected function applyDoc(File $sourceCodeFile, $doc = ''): void
    {
        $class = $this->objectReflection->getShortName();
        $content = $sourceCodeFile->content();

        if (preg_match('/(\/\*\*.*?\*\/)\s*class\s+('.$class.')/s', $content, $match)){
            $content = Str::replaceFirst($match[1], $doc, $content);
            $sourceCodeFile->put($content);
            $this->message("{$class}: OK");
            return;
        }

        if (preg_match('/class\s+'.$class.'/s', $content, $match)){
            $content = Str::replaceFirst($match[0], "{$doc}\n{$match[0]}", $content);
            $sourceCodeFile->put($content);
            $this->message("{$class}: OK");
            return;
        }

        $this->message("{$class}: Failed");
    }

    /**
     * @param $path
     * @param null $file
     * @return array
     * @throws Exception
     */
    protected function getFiles($path, $file = null){
        if (is_null($file)){
            $dir = Dir::bind($path);
            return $dir->map(function(FileInfo $file){
                return File::bind($file->realPath);
            });
        } else {
            $file = File::bind($path.DIRECTORY_SEPARATOR.$file);
            $file->missing(function($file){
                $this->error("File [{$file->realPath}] not found");
                die();
            });
            return [$file];
        }
    }

    /**
     * @param string $class
     * @param string $content
     * @return string
     * @throws ReflectionException
     */
    protected function classNameNormalization(string $class, string $content){
        $class = trim($class);

        if (empty($class) or empty($content)){
            return $class;
        }

        if (strpos($class, '|') !== false){
            $class = preg_replace('/\|+/', '|', $class);
            $class = explode('|', $class);
            foreach ($class as $classIndex => $classItem){
                $class[$classIndex] = $this->classNameNormalization($classItem, $content);
            }
            return implode('|', $class);
        }

        if (preg_match('/use\s+\\\\?' . preg_quote($class) . '\s*(?:as\s+([\w+]+))?;[^;]/is', $content, $matches)) {
            if (!empty($matches[1])){
                return $matches[1];
            }
            return (new ReflectionClass($class))->getShortName();
        }

        if (strpos($class, '\\') === false){
            return $class;
        }

        if (strpos($class, $this->objectReflection->getNamespaceName()) === 0){
            return str_replace($this->objectReflection->getNamespaceName().'\\', '', $class);
        }

        return '\\' . $class;
    }
}

try{
    (new Mapper())->execute();
} catch (Exception $e){
    (new ConsoleLauncher())->error($e->getMessage());
}
